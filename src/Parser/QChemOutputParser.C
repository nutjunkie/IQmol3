/*******************************************************************************

  Copyright (C) 2022 Andrew Gilbert

  This file is part of IQmol, a free molecular visualization program. See
  <http://iqmol.org> for more details.

  IQmol is free software: you can redistribute it and/or modify it under the
  terms of the GNU General Public License as published by the Free Software
  Foundation, either version 3 of the License, or (at your option) any later
  version.

  IQmol is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  You should have received a copy of the GNU General Public License along
  with IQmol.  If not, see <http://www.gnu.org/licenses/>.  
   
********************************************************************************/

#include "CartesianCoordinatesParser.h"
#include "QChemOutputParser.h"
#include "QChemInputParser.h"
#include "XyzParser.h"
#include "TextStream.h"

#include "Data/AtomicProperty.h"
#include "Data/Constraint.h"
#include "Data/DipoleMoment.h"
#include "Data/EfpFragmentLibrary.h"
#include "Data/EfpFragment.h"
#include "Data/Energy.h"
#include "Data/Frequencies.h"
#include "Data/Geometry.h"
#include "Data/Hessian.h"
#include "Data/DysonOrbitals.h"
#include "Data/OrbitalsList.h"
#include "Data/PointGroup.h"
#include "Data/MultipoleExpansion.h"
#include "Data/NmrReference.h"
#include "Data/ShellList.h"
#include "Data/RemSectionData.h"
#include "Data/NmrData.h"

#include "Math/Numerical.h"
#include "Math/Matrix.h"

#include "Util/Constants.h"
#include "Util/Spin.h"
#include "Util/QsLog.h"

#include <QRegularExpression>
#include <QFile>
#include <QtDebug>



using qglviewer::Vec;

namespace IQmol {
namespace Parser {

QStringList QChemOutput::parseForErrors(QString const& filePath)
{
   QStringList errors;

   QFile file(filePath);
   if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
      TextStream textStream(&file);
      errors = parseForErrors(textStream);
      file.close();
   }else {
      errors.append("Unable to open file");
   }

   return errors;
}

   
QStringList QChemOutput::parseForErrors(TextStream& textStream)
{

   QStringList errors;
   QString line;

   int nJobs(0);
   int nNiceEndings(0);
   double time(0.0);

   QRegularExpression rx("Total job time:(.+)s\\(wall\\)");

   QString error;

   while (!textStream.atEnd()) {
      line = textStream.readLine();

      if (line.contains("Q-Chem fatal error")) {
         textStream.skipLine();  // blank line
         line = textStream.readLine().trimmed();
         do {
            error += line + " ";
            line = textStream.readLine().trimmed();
         }  while (!line.isEmpty());

         if (error.isEmpty()) error = "Fatal error occured at end of output file";

      }else if (line.contains("Time limit has been exceeded")) {
         error = "Time limit on Q-Chem public server has been exceeded.\n"
                 "Please consider installing your own copy of Q-Chem to \n"
                 "remove this limitation.";

      }else if (line.contains("Welcome to Q-Chem")) {
         if (!error.isEmpty()) {
            errors.append(error);
         }
         error.clear();
         ++nJobs;

      }else if (line.contains("Have a nice day")) {
         ++nNiceEndings;

      }else {
         QRegularExpressionMatch match(rx.match(line));
         if (match.hasMatch()) {
            bool ok(false);
            double t(match.captured(1).toDouble(&ok));
            if (ok) time += t;
         }
      }
   }

   if (!error.isEmpty()) {
      qDebug() << "Appending error:" << error;
      errors.append(error);
   }

   if (nNiceEndings < nJobs) {
      nJobs -= nNiceEndings;
      if (nJobs == 1) {
        errors.append("Job failed to finish");
      }else {
        errors.append(QString::number(nJobs) + " Jobs failed");
      }
   }

   int t(time);
   if (t == 0) t = 1;
   errors.append("Time: " + QString::number(t));

   return errors;
}


struct DysonData {
   QString       label;
   QStringList   labels;
   QList<double> leftCoefficients;
   QList<double> rightCoefficients;
   QList<double> energies;
};


bool QChemOutput::parse(TextStream& textStream)
{
   // A single output file can contain multiple jobs, but they all must
   // correspond to a single molecule (possibly with different geometries).
   // We use the first Geometry found to check all the others.
   Data::Geometry*     firstGeometry(0);
   Data::Geometry*     currentGeometry(0);
   Data::GeometryList* geometryList(0);
   Data::GeometryList* scanGeometries(0);
   Data::ShellList*    shellList(0);
   Data::Nmr* nmr(0);


   DysonData dysonData;

   m_nAlpha = 0;
   m_nBeta  = 0;
   QString method;

   QStringList tokens;
   QString line;

   // This is a hack as the FSM jobs print out the wrong format for the SCF
   // energy.
   bool isFSM(false);

   // Another hack.  We need a petite list of atoms for partial hessian calculations
   QList<unsigned> partialHessianAtomList;

   // More hacks.  This time for excited state PES scans.
   double finalEnergy(0);

   while (!textStream.atEnd()) {
      line = textStream.nextLine();

      if (line.contains("Welcome to Q-Chem")) {
/*
         if (geometryList && !geometryList->isEmpty()) {
            m_dataBank.append(geometryList);
            geometryList = 0;
            currentGeometry = 0;
         }
*/

      }else if (line.contains("Q-Chem fatal error occurred in module")) {
         textStream.skipLine();
         QString msg("Q-Chem fatal error line ");
         msg += QString::number(textStream.lineNumber()) + ":\n";
         line = textStream.readLine().trimmed();
         do {
            msg += line + " ";
            line = textStream.readLine().trimmed();
         }  while (!line.isEmpty());

         m_errors.append(msg);

      }else if (line.contains("Time limit has been exceeded")) {
         if (!m_errors.isEmpty()) m_errors.removeLast();
         m_errors.append("Time limit has been exceeded");

      }else if (line.contains("User input:") && !line.contains(" of ")) {
         textStream.skipLine();
         QChemInput parser;
         if (parser.parse(textStream)) {
            Data::Bank& bank(parser.data());

            // Remove the input geometry list
            bank.deleteData<Data::GeometryList>();
            bank.deleteData<Data::Geometry>();
            m_dataBank.merge(bank);
         }else {
            m_errors << parser.errors();
         }

      }else if (line.contains("Standard Nuclear Orientation (Angstroms)") || 
                line.contains("Standard Nuclear Orientation (Bohr)") ) {

         bool convertFromBohr(line.contains("Bohr"));
         textStream.skipLine(2);
         Data::Geometry* geometry(readStandardCoordinates(textStream));

         if (geometry) {
            if (convertFromBohr) geometry->scaleCoordinates(Constants::BohrToAngstrom);
            if (!firstGeometry) firstGeometry = geometry;

            if (!geometryList) {
               geometryList = new Data::GeometryList;
               currentGeometry = 0;
            }

            if (geometry->sameAtoms(*firstGeometry)) {
               int charge(firstGeometry->charge());
               int multiplicity(firstGeometry->multiplicity());
               geometry->setChargeAndMultiplicity(charge, multiplicity);
               geometryList->append(geometry);

               currentGeometry = geometry;
            }else if (geometryList->isEmpty()) {
               // Different geometry found, which is unsupported.
               m_errors.append("More than one molecule found in file");
               break; 
            }else {
               // Different geometry found, possibly from EFPs.  We ignore it.
            }
         }else {
            QString msg("Problem parsing coordinates, line number ");
            m_errors.append(msg + QString::number(textStream.lineNumber()));
            break;
         }

      }else if (line.contains("Starting FSM Calculation")) {
         isFSM = true;

      }else if (line.contains("STARTING GEOMETRY OPTIMIZER USING LIBOPT3")) {
         // Ditch the last geometry as it will be repeated.
         if (!geometryList->isEmpty()) {
            Data::TotalEnergy energy(geometryList->last()->getProperty<Data::TotalEnergy>());
            if (std::abs(energy.value()) < 0.000001) geometryList->removeLast();
         }

      }else if (line.contains("END OF GEOMETRY OPTIMIZER USING LIBOPT3")) {
         // Ditch the last geometry as it was repeated.
         if (!geometryList->isEmpty()) {
            Data::TotalEnergy energy(geometryList->last()->getProperty<Data::TotalEnergy>());
            if (std::abs(energy.value()) < 0.000001) geometryList->removeLast();
         }
         
      }else if (line.contains("Final energy is")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() > 3) {
            bool ok(false);
            finalEnergy = tokens[3].toDouble(&ok);
            if (!ok) { QLOG_WARN() << "Invalid final energy" << tokens[3];}
         }

      }else if (line.contains("PES scan, value:")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() > 5 && currentGeometry) {
            bool   energyOk(false), valueOk(false);
            double value(tokens[3].toDouble(&valueOk));
            double energy(tokens[5].toDouble(&energyOk));

            if (energyOk && valueOk) {
               if (!scanGeometries) scanGeometries = new Data::GeometryList("Scan Geometries");
               Data::Geometry* geom(new Data::Geometry(*currentGeometry));
               Data::TotalEnergy& total(geom->getProperty<Data::TotalEnergy>());
               //total.setValue(energy, Data::Energy::Hartree);
               total.setValue(finalEnergy, Data::Energy::Hartree);
               Data::Constraint& constraint(geom->getProperty<Data::Constraint>());
               constraint.setValue(value);
               scanGeometries->append(geom);
            }
         }

      }else if (line == "STRING") {
         textStream.skipLine(1);
         QString nodes;
         while (!line.contains("--------")) {
             line = textStream.nextLine();
             nodes += line + "\n";
         }

         Xyz parser("FSM Geometries");
         TextStream fsmStream(&nodes);
         if (parser.parse(fsmStream)) {
            Data::Bank& bank(parser.data());
            m_dataBank.merge(bank); 
         }

      }else if (line.contains("Requested basis set is")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() == 5) {
            QList<Data::RemSection*> rem(m_dataBank.findData<Data::RemSection>());
            if (!rem.isEmpty()) {
               method = rem.last()->value("method").toUpper();
               method += "/" + tokens[4];
               //qDebug() << "Setting method to" << method;
            }

         }

      }else if (line.contains("Molecular Point Group")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() > 3 && currentGeometry) {
            Data::PointGroup& pg = currentGeometry->getProperty<Data::PointGroup>();
            pg.setPointGroup(tokens[3]);
         }

      }else if (line.contains("beta electrons")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() >= 6) {
            bool ok;
            m_nAlpha = tokens[2].toUInt(&ok);
            m_nBeta  = tokens[5].toUInt(&ok);
            currentGeometry->setMultiplicity(m_nAlpha-m_nBeta + 1);
         }

      }else if (line.contains("Total energy in the final basis set") ||
                (isFSM && line.contains("Total energy in the small basis set")) ) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() == 9 && currentGeometry) {
            bool ok;
            double energy(tokens[8].toDouble(&ok));
            if (ok) {
               Data::ScfEnergy& scf(currentGeometry->getProperty<Data::ScfEnergy>());
               scf.setValue(energy, Data::Energy::Hartree);
               Data::TotalEnergy& total(currentGeometry->getProperty<Data::TotalEnergy>());
               total.setValue(energy, Data::Energy::Hartree);
            }
         }

      }else if (line.contains("SCF   energy =")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() == 4 && currentGeometry) {
            bool ok;
            double energy(tokens[3].toDouble(&ok));
            if (ok) {
               Data::ScfEnergy& scf(currentGeometry->getProperty<Data::ScfEnergy>());
               scf.setValue(energy, Data::Energy::Hartree);
            }
         }

      }else if (line.contains("Total energy =")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() == 4 && currentGeometry) {
            bool ok;
            double energy(tokens[3].toDouble(&ok));
            if (ok) {
               Data::TotalEnergy& total(currentGeometry->getProperty<Data::TotalEnergy>());
               total.setValue(energy, Data::Energy::Hartree);
            }
         }

      }else if (line.contains("RIMP2         total energy")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() >= 5) setTotalEnergy(tokens[4], currentGeometry, "RIMP2");

      }else if (line.contains("RI-MP2 TOTAL ENERGY")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() >= 5) setTotalEnergy(tokens[4], currentGeometry, "RIMP2");

      }else if (line.contains("Total SOS-MP2 energy")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() >= 5) setTotalEnergy(tokens[4], currentGeometry, "SOS-MP2");

      }else if (line.contains("Total MOS-MP2 energy")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() >= 5) setTotalEnergy(tokens[4], currentGeometry, "MOS-MP2");

      }else if (line.contains("TRIM MP2           total energy  =")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() >= 6) setTotalEnergy(tokens[5], currentGeometry, "TRIM-MP2");

      }else if (line.contains("MP2[V]      total energy")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() >= 5) setTotalEnergy(tokens[4], currentGeometry, "MP2[V]");
 
      }else if (line.contains("MP2         total energy")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() >= 5) setTotalEnergy(tokens[4], currentGeometry, "MP2");

      }else if (line.contains("CCSD total energy          =")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() == 5) setTotalEnergy(tokens[4], currentGeometry, "CCSD");

      }else if (line.contains("CCD total energy           =")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() == 5) setTotalEnergy(tokens[4], currentGeometry, "CC");

      }else if (line.contains("EMP4                   =")) {
         tokens = TextStream::tokenize(line);
         if (tokens.size() == 3) setTotalEnergy(tokens[2], currentGeometry, "MP4");

      }else if (line.contains("   Energy is   ")) { 
         // Over-ride for geometry optimizations, which might be on an excited state
         tokens = TextStream::tokenize(line);
         if (tokens.size() == 3) setTotalEnergy(tokens[2], currentGeometry);

      }else if (line.contains("Ground-State Mulliken Net Atomic Charges")) {
         textStream.skipLine(3);
         if (currentGeometry) 
            readCharges(textStream, *currentGeometry, Data::Type::MullikenCharge);

      }else if (line.contains("Ground-State ChElPG Net Atomic Charges")) {
         textStream.skipLine(3);
         if (currentGeometry) 
            readCharges(textStream, *currentGeometry, Data::Type::ChelpgCharge);

      }else if (line.contains("Hirshfeld Atomic Charges")) {
         textStream.skipLine(3);
         if (currentGeometry) 
            readCharges(textStream, *currentGeometry, Data::Type::HirshfeldCharge);
 
      }else if (line.contains("Stewart Net Atomic Charges")) {
         textStream.skipLine(3);
         if (currentGeometry) 
            readCharges(textStream, *currentGeometry, Data::Type::MultipoleDerivedCharge);

      }else if (line.contains("Lowdin Net Atomic Charges")) {
         textStream.skipLine(3);
         if (currentGeometry) 
            readCharges(textStream, *currentGeometry, Data::Type::LowdinCharge);

      }else if (line.contains("Summary of Natural Population Analysis")) {
         textStream.skipLine(5);
         if (currentGeometry) 
            readNBO(textStream, *currentGeometry, Data::Type::NaturalCharge);

      }else if (line.contains("Orbital Energies (a.u.) and Symmetries")) {
         textStream.skipLine(2);
         bool readSymmetries(true);
         readOrbitalSymmetries(textStream, readSymmetries);

      }else if (line.contains("Orbital Energies (a.u.)")) {
         textStream.skipLine(2);
         bool readSymmetries(false);
         readOrbitalSymmetries(textStream, readSymmetries);

      }else if (line.contains("TDDFT Excitation Energies")) {
         textStream.skipLine(2);
         Data::ExcitedStates* states(readCisStates(textStream, Data::ExcitedStates::TDDFT));
         if (states) { m_dataBank.append(states); }
         
      }else if (line.contains("CIS Excitation Energies") ||
                line.contains("TDDFT/TDA Excitation Energies")) {
         textStream.skipLine(2);
         Data::ExcitedStates* states(readCisStates(textStream, Data::ExcitedStates::CIS));
         if (states) { m_dataBank.append(states); }

      }else if (line.contains("CIS(D) Excitation Energies")) {
         textStream.skipLine(2);
         readCisdStates(textStream);
 
      }else if (line.contains("Reference values")) {
         textStream.skipLine(1);
         if (!nmr) nmr = new Data::Nmr;
         readNmrReference(textStream, *nmr);
    
      }else if (line.contains("ATOM           ISOTROPIC        ANISOTROPIC       REL.")) {
         textStream.skipLine(1);
         if (!nmr) nmr = new Data::Nmr;
         nmr->setMethod(method);
         if (currentGeometry) readNmrShifts(textStream, *currentGeometry, *nmr);

      }else if (line.contains("Indirect Nuclear Spin--Spin")) {
         textStream.skipLine(11);
         if (!nmr) nmr = new Data::Nmr;
         if (currentGeometry) readNmrCouplings(textStream, *currentGeometry, *nmr);

      }else if (line.contains("Cartesian Multipole Moments")) {
         textStream.skipLine(4);
         if (currentGeometry) readDipoleMoment(textStream, *currentGeometry);

      }else if (line.contains("Partial Hessian Calculation")) {
         if (currentGeometry) readPartialHessian(textStream, *currentGeometry, 
             partialHessianAtomList);

      }else if (line.contains("Hessian of the SCF Energy") || 
                line.contains("Final Hessian.")) {
         if (currentGeometry) readHessian(textStream, *currentGeometry);

      }else if (line.contains("VIBRATIONAL ANALYSIS")) {
         textStream.seek("Mode:");
         readVibrationalModes(textStream, *currentGeometry, partialHessianAtomList);
         partialHessianAtomList.clear();

      }else if (line.contains("DISTRIBUTED MULTIPOLE ANALYSIS")) {
         textStream.skipLine(4);
         if (currentGeometry) readDMA(textStream, *currentGeometry);

      }else if (line.contains("Basis set in general basis input format:")) {
         if (currentGeometry) shellList = readBasis(textStream, *currentGeometry);

      // Dyson orbitals
      }else if (line.contains("transition") && 
                line.contains("state")      && 
                line.contains("EOM") ) {
         dysonData.label = line;
         readDyson(textStream, dysonData);

      // There is a typo in the print out of the word Coordinates
      }else if (line.contains("atoms in the effective region (ANGSTROMS)")) {
         textStream.skipLine();
         readEffectiveRegion(textStream);
      }
   }

   if (geometryList) {
      if (geometryList->isEmpty()) {
         delete geometryList;
      }else {
         geometryList->setDefaultIndex(-1);
         m_dataBank.append(geometryList);
      }
   }

   if (scanGeometries) {
      if (scanGeometries->isEmpty()) {
         delete scanGeometries;
      }else {
         m_dataBank.append(scanGeometries);
      }
   }

   if (shellList) {
      int n(dysonData.labels.size());

      if (n > 0) {
         dumpDyson(dysonData);

         Data::Orbitals* dyson = new Data::DysonOrbitals(*shellList, 
            dysonData.leftCoefficients, dysonData.rightCoefficients, 
            dysonData.energies, dysonData.labels);
              
         if (dyson->consistent()) {
            dyson->reorderFromQChem();
            Data::OrbitalsList* orbitalsList(new Data::OrbitalsList());
            orbitalsList->append(dyson);
            m_dataBank.append(orbitalsList);
         }else {
            m_errors.append("Inconsistent Dyson data encountered");
         }
      }
   }

   if (nmr) {
      nmr->dump();
      m_dataBank.append(nmr);
   }

   return m_errors.isEmpty();
}



void QChemOutput::dumpDyson(DysonData const& dysonData)
{
qDebug() << "Dumping Dyson data from outout file:";

   for (int i = 0; i < dysonData.labels.size(); ++i) {
       qDebug() << "Dyson label" << dysonData.labels[i];
   }
   for (int i = 0; i < dysonData.energies.size(); ++i) {
       qDebug() << "Dyson energy" << dysonData.energies[i];
   }

   qDebug() << dysonData.labels.size();
   qDebug() << dysonData.energies.size();
   qDebug() << dysonData.leftCoefficients.size() << dysonData.rightCoefficients.size();
}


void QChemOutput::readDyson(TextStream& textStream, DysonData& dysonData)
{  
qDebug() << "QChemOutput::readDyson called with label" << dysonData.label;
   QStringList tokens(textStream.nextLineAsTokens());
   if (tokens.size() < 4 || tokens[0] != "Energy" || tokens[1] != "difference") return;

   bool ok;
   double energy(tokens[3].toDouble(&ok)), x;
   if (!ok) return;

   textStream.skipLine();
   QString line(textStream.nextLine());
   if (!line.contains("Left Dyson")) return;

   dysonData.label.remove("transition");
   dysonData.label = dysonData.label.trimmed();

   QChar alpha(0x3b1);
   QChar beta(0x3b2);

   while (!textStream.atEnd()) {
      line = textStream.readLine();
      if (line.contains("End transition")) return;

      if (line.contains("Decomposition over AOs for the left alpha Dyson orbital")) {
         dysonData.labels.append(dysonData.label + " " + alpha);
         dysonData.energies.append(energy);
         
         line = textStream.nextLine();
         while (!line.contains("****")) {
            x = line.toDouble(&ok);
            if (ok) dysonData.leftCoefficients.append(x);
            line = textStream.nextLine();
         }

      }else if (line.contains("Decomposition over AOs for the right alpha Dyson orbital")) {
         //dysonData.labels.append(dysonData.label + " (right alpha)");
         //dysonData.energies.append(energy);

         line = textStream.nextLine();
         while (!line.contains("****")) {
            x = line.toDouble(&ok);
            if (ok) dysonData.rightCoefficients.append(x);
            line = textStream.nextLine();
         }

      }else if (line.contains("Decomposition over AOs for the left beta Dyson orbital")) {
         dysonData.labels.append(dysonData.label + " " + beta);
         dysonData.energies.append(energy);

         line = textStream.nextLine();
         while (!line.contains("****")) {
            x = line.toDouble(&ok);
            if (ok) dysonData.leftCoefficients.append(x);
            line = textStream.nextLine();
         }

      }else if (line.contains("Decomposition over AOs for the right beta Dyson orbital")) {
         //dysonData.labels.append(dysonData.label + " (right beta)");
         //dysonData.energies.append(energy);

         line = textStream.nextLine();
         while (!line.contains("****")) {
            x = line.toDouble(&ok);
            if (ok) dysonData.rightCoefficients.append(x);
            line = textStream.nextLine();
         }
      }
   }
}



// This assumes bases are printed for all the atoms in the same order as the geometry
Data::ShellList* QChemOutput::readBasis(TextStream& textStream, Data::Geometry& geometry)
{
   Data::ShellData shellData;
   QStringList tokens;
   QString line;
   QList<double> x;
   unsigned index(1), K;
   unsigned nBasis(0);
   bool ok;

   textStream.seek("$basis");
   textStream.skipLine();  // skip over the first element and '0' line

   Data::ShellList* shells(0);

   while (!textStream.atEnd()) {
      line = textStream.readLine();

      if (line.contains("****")) {
         ++index;
         line = textStream.readLine();
         if (line.contains("$end")) break;
      }else {
         tokens = TextStream::tokenize(line);
         if (tokens.size() != 3) goto error;
         K = tokens[1].toUInt(&ok);
         if (!ok) goto error;

         // We assume cartesian for the time being, but will fix
         // this later if we have the wrong number of basis functions.
         if (tokens[0] == "S")  { shellData.shellTypes.append( 0);  nBasis +=  1; }
         if (tokens[0] == "P")  { shellData.shellTypes.append( 1);  nBasis +=  3; }
         if (tokens[0] == "SP") { shellData.shellTypes.append(-1);  nBasis +=  4; }
         if (tokens[0] == "D")  { shellData.shellTypes.append( 2);  nBasis +=  6; }
         if (tokens[0] == "F")  { shellData.shellTypes.append( 3);  nBasis += 10; }
         if (tokens[0] == "G")  { shellData.shellTypes.append( 4);  nBasis += 15; }

         shellData.shellToAtom.append(index);
         shellData.shellPrimitives.append(K);

         qDebug() << "Reading " << K << "primitives for shell L =" << tokens[0];   

         for (unsigned i = 0; i < K; ++i) {
             x = textStream.nextLineAsDoubles();
             if (x.size() == 2) {
                shellData.exponents.append(x[0]);
                shellData.contractionCoefficients.append(x[1]);
                shellData.contractionCoefficientsSP.append(0.0);
             }else if (x.size() == 3) { 
                shellData.exponents.append(x[0]);
                shellData.contractionCoefficients.append(x[1]);
                shellData.contractionCoefficientsSP.append(x[2]);
             }
         }
         
      }
   }

   // Fix the pure/cart status if we have the wrong number of basis functions
   textStream.skipLine();  // skip over the ------------------------------ line
   line = textStream.readLine();
   if (line.contains("There are") && line.contains("basis functions")) {
      tokens = TextStream::tokenize(line);
      if (tokens.size() >= 6) {
         unsigned n(0);
         n = tokens[5].toUInt(&ok);
         if (ok && n != nBasis) {
            nBasis = n;
            QLOG_INFO() << "Non-cartesian functions detected, pure conversion applied";

            int nShells(shellData.shellTypes.size());
            for (int i = 0; i < nShells; ++i) {
                if (shellData.shellTypes[i] > 1)  {
                    shellData.shellTypes[i] = -shellData.shellTypes[i];
                }
            }
         }
      }
   }
   
   qDebug() << "ShellData" << shellData.exponents.size();
   qDebug() << "ShellData" << shellData.contractionCoefficients.size();
   qDebug() << "ShellData" << shellData.contractionCoefficientsSP.size();
   qDebug() << shellData.shellToAtom;
   qDebug() << shellData.shellPrimitives;

   shells = new Data::ShellList(shellData, geometry);
   if (shells->nBasis() == nBasis)  return shells;

   delete shells;

   error:
     QString msg("Problem parsing general basis section, line number ");
     m_errors.append(msg += QString::number(textStream.lineNumber()));

   return 0;
}


Data::ExcitedStates* QChemOutput::readCisStates(TextStream& textStream,
   Data::ExcitedStates::ExcitedStatesT type)
{
   Data::ExcitedStates* states(new Data::ExcitedStates(type));
//qDebug() << "Reading" << states->typeLabel() << "States";

   QStringList tokens;

   QString label, line;
   double energy(0.0), strength(0.0), s2(0.0);
   bool ok;
   qglviewer::Vec moment;

   // This is to match lines similar to the following
   //  D(  7) --> S(  1) amplitude =  0.6732 beta
   QRegularExpression 
      rx("([DS])\\(\\s*(\\d+)\\) --> ([VS])\\(\\s*(\\d+)\\) amplitude = (.{7})\\s?([ab]?)");
   
   while (!textStream.atEnd()) {
      tokens = textStream.nextLineAsTokens();
      int size(tokens.size());

      if (size == 0) {
         // do nothing
      }else if (tokens[0].contains("-------------------------------------------")) {
         break;

      }else if (size >= 8 && tokens[0].contains("Excited")) {
         energy = tokens[7].toDouble(&ok);
         if (!ok) goto error;

      }else if (size >= 2 && tokens[0].contains("Multiplicity")) {
         if (tokens[1].contains("Singlet")) {
            s2 = 0.0;
         }else if (tokens[1].contains("Triplet")) {
            s2 = 2.0;
         }else {
            s2 = tokens[1].toDouble(&ok);
            if (!ok) {
               QLOG_WARN() << "Failed to convert S^2 value for transition";
               s2 = 0.0;
            }
         }

         label = tokens[1];

      }else if (size >= 8 && tokens[0].contains("Trans")) {

         moment.x = tokens[2].toDouble(&ok);  if (!ok) goto error;
         moment.y = tokens[4].toDouble(&ok);  if (!ok) goto error;
         moment.z = tokens[6].toDouble(&ok);  if (!ok) goto error;

      }else if (size >= 3 && tokens[0].contains("Strength")) {
         strength = tokens[2].toDouble(&ok);  if (!ok) goto error;

         Data::ElectronicTransition* transition(
            new Data::ElectronicTransition(energy, strength, moment, s2));

         while (!textStream.atEnd()) {
            line = textStream.nextLine();
            QRegularExpressionMatch match(rx.match(line));
            if (!match.hasMatch()) break;
            if (!transition->addAmplitude(match.capturedTexts().mid(1), m_nAlpha, m_nBeta)) {
               goto error;
            }
         }
     
         states->append(transition);
      }
   }

   //states->dump();

   if (states->nTransitions() == 0) {
      delete states;
      states = 0;
   }

   return states;

   error:
     QString msg("Problem parsing excited states section, line number ");
     m_errors.append(msg += QString::number(textStream.lineNumber()));
     delete states;

     return 0;
}



void QChemOutput::readCisdStates(TextStream& textStream)
{
   qDebug() << "Reading CIS(D) Energies";
   // We should already have the CIS energies lying around
   QList<Data::ExcitedStates*> es(m_dataBank.findData<Data::ExcitedStates>());
   if (es.isEmpty()) return;

   Data::ExcitedStates* states(es.last());
   unsigned nStates(states->nTransitions());
   if (nStates == 0) return;

   bool ok;
   QString line;
   double energy;
   unsigned nFound(0);
   QStringList tokens;

   QList<double> singlets;
   QList<double> triplets;


   while (!textStream.atEnd() && nFound < nStates) {
      line = textStream.seek("CIS(D) excitation energy for state");
      tokens = TextStream::tokenize(line);

	  // We need to account for the restricted and unrestricted separately as
	  // the order in which the states are printed differs.
      if (tokens.size() == 10) {      // Restricted case, includes "singlet"/"triplet"
         energy = tokens[8].toDouble(&ok);
         if (!ok) goto error;

         if (tokens[6] == "triplet") {
            triplets.append(energy);
         }else {
            singlets.append(energy);
         }
         ++nFound;
      }else if (tokens.size() == 9) { // Unrestricted case
         energy = tokens[7].toDouble(&ok);
         if (!ok) goto error;
         singlets.append(energy);
         ++nFound;
      }
   }
   
   if (nFound != nStates) goto error;

   states->setCisdEnergies(singlets, triplets);
   return;

   error:
     QString msg("Problem parsing excited states section, line number ");
     m_errors.append(msg += QString::number(textStream.lineNumber()));
}


void QChemOutput::readOrbitalSymmetries(TextStream& textStream, bool const readSymmetries)
{
//   qDebug() << "Reading orbital energies";
   // We only parse the orbital symmetries section if we have excited states
   QList<Data::ExcitedStates*> es(m_dataBank.findData<Data::ExcitedStates>());
   if (es.isEmpty()) return;

   Data::OrbitalSymmetries& data(es.last()->orbitalSymmetries());
   Data::Spin spin(Data::Alpha);

   unsigned nOrb(0);
   QStringList tokens;
   QStringList symmetries;

   while (!textStream.atEnd()) {
      tokens = textStream.nextLineAsTokens(); 

      if (tokens.isEmpty()) {
         // do nothing
      }else if (tokens[0].contains("--------------")) {
         break;
      }else if (tokens[0].contains("Alpha")) {
         spin = Data::Alpha;
      }else if (tokens[0].contains("Beta")) {
         spin = Data::Beta;

      }else if (tokens[0] == ("--") && tokens[1].contains("Occupied")) {
         nOrb = 0;
      }else if (tokens[0] == ("--") && tokens[1].contains("Virtual")) {
         data.setOccupied(spin, nOrb);
      }else {
         if (readSymmetries) {
            symmetries = textStream.nextLineAsTokens();
            if (2*tokens.size() != symmetries.size()) goto error;
         }

         bool ok;
         double energy;
         QString symmetry;

         for (int i = 0; i < tokens.size(); ++i) {
             energy   = tokens[i].toDouble(&ok);   if (!ok) goto error;
             if (readSymmetries) {
                symmetry = symmetries.at(2*i);
                symmetry += " " + symmetries.at(2*i + 1);
             }else {
                symmetry = "A";
             }
             data.append(spin, energy, symmetry);
             ++nOrb;
         }
      } 
   }

   return;

   error:
     QString msg("Problem parsing excited states section, line number ");
     m_errors.append(msg += QString::number(textStream.lineNumber()));
}


void QChemOutput::readDMA(TextStream& textStream, Data::Geometry& geometry)
{
   Data::MultipoleExpansionList* dma(new Data::MultipoleExpansionList);
   Data::MultipoleExpansion* site;
   
   QList<double> x;
   QString line;

   // Charges and positions
   while (!textStream.atEnd()) {
      x = textStream.nextLineAsDoubles();
      if (x.size() < 5) break;
      site = new Data::MultipoleExpansion(Vec(x[1], x[2], x[3]));
      site->addCharge(x[4]);
      dma->append(site);
   }

   if (dma->isEmpty()) {
      delete dma;
      return;
   }

   geometry.appendProperty(dma);

   line = textStream.nextLine();
   if (!line.contains("DIPOLES")) return;
   textStream.skipLine(2);

   int nSites(0);
   while (!textStream.atEnd()) {
      x = textStream.nextLineAsDoubles();
      if (x.size() < 4) break;
      dma->at(nSites)->addDipole(x[1], x[2], x[3]);
      ++nSites;
   }

   // Digest the nuclear and electronic charges, which are given separately
   if (nSites < dma->size()) {
      int nAtoms(dma->size()-nSites);
      for (int i = nAtoms-1; i >= 0; --i) {
          site = dma->takeLast();
          *(dma->at(i)) += *site;
      //    delete site;
      }
   }else {
      goto error;
   }

   line = textStream.nextLine();
   if (!line.contains("QUADRUPOLES")) return;
   textStream.skipLine(2);

   for (int i = 0; i < nSites; ++i) {
       x = textStream.nextLineAsDoubles();
       if (x.size() < 5)  goto error;
       dma->at(i)->addQuadrupole(x[1], x[2], x[3], x[4], 0.0, 0.0);
   }

   textStream.skipLine(2);
   for (int i = 0; i < nSites; ++i) {
       x = textStream.nextLineAsDoubles();
       if (x.size() < 3)  goto error;
       dma->at(i)->addQuadrupole(0.0, 0.0, 0.0, 0.0, x[1], x[2]);
   }

   textStream.skipLine();
   line = textStream.nextLine();
   if (!line.contains("OCTUPOLES")) return;

   textStream.skipLine(2);
   for (int i = 0; i < nSites; ++i) {
       x = textStream.nextLineAsDoubles();
       if (x.size() < 5)  goto error;
       dma->at(i)->addOctopole(x[1], x[2], x[3], x[4], 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
   }

   textStream.skipLine(2);
   for (int i = 0; i < nSites; ++i) {
       x = textStream.nextLineAsDoubles();
       if (x.size() < 5)  goto error;
       dma->at(i)->addOctopole(0.0, 0.0, 0.0, 0.0, x[1], x[2], x[3], x[4], 0.0, 0.0);
   }

   textStream.skipLine(2);
   for (int i = 0; i < nSites; ++i) {
       x = textStream.nextLineAsDoubles();
       if (x.size() < 3)  goto error;
       dma->at(i)->addOctopole(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, x[1], x[2]);
   }

   return;

   error:
     QString msg("Problem parsing DMA, line number ");
     m_errors.append(msg += QString::number(textStream.lineNumber()));
}


void QChemOutput::setTotalEnergy(QString const& field, Data::Geometry* geometry, 
   QString const& label)
{
   if (!geometry) return;
   bool ok;
   double energy(field.toDouble(&ok));
   if (!ok) return;
   Data::TotalEnergy& data(geometry->getProperty<Data::TotalEnergy>());
   data.setValue(energy, Data::Energy::Hartree);
   if (!label.isEmpty()) data.setLabel(label + " energy");
}


void QChemOutput::readEffectiveRegion(TextStream& textStream)
{
   CartesianCoordinates parser;
   Data::Geometry* geometry(parser.parse(textStream));
   QList<Data::EfpFragmentList*> fragmentLists(m_dataBank.findData<Data::EfpFragmentList>());

   if (fragmentLists.isEmpty() || !geometry) {
      m_errors.append("Problem parsing EFP coordinates");
      delete geometry;
      return;
   }

   Data::EfpFragmentList* list(fragmentLists.last());
   Data::EfpFragmentLibrary& library(Data::EfpFragmentLibrary::instance());
   QList<Vec> coordinates(geometry->coordinates());
   delete geometry;

   QString name;
   int n, count(0);

   qDebug() << "Initial EFP alignment:";
   list->dump();

   Data::EfpFragmentList::iterator fragment;
   for (fragment = list->begin(); fragment != list->end(); ++fragment) {
       name = (*fragment)->name();
       // need to determine how many atoms are in the fragment
       if (!library.defined(name)) {
          m_errors.append("Fragment not found in library");
          return;
       }

       n = library.geometry(name).nAtoms();
       if (count + n > coordinates.size()) {
          m_errors.append("Too many EFP coordinates found");
          return;
       }
       
       if (!(*fragment)->align(coordinates.mid(count,n))) {
          m_errors.append("Problem with EFP alignment");
          return;
       }
       count += n;
   }

   qDebug() << "New EFP alignment:";
   list->dump();
}


void QChemOutput::readVibrationalModes(TextStream& textStream, Data::Geometry& geometry,
    QList<unsigned> const& partialHessianAtomList)
{
   QString line;
   QStringList tokens;
   double x, y, z, w;
   double zpve(0.0), enthalpy(0.0), entropy(0.0);
   bool ok;
   unsigned nAtoms(geometry.nAtoms());

   Data::VibrationalMode* v1(0);
   Data::VibrationalMode* v2(0);
   Data::VibrationalMode* v3(0);
   Data::Frequencies* frequencies = new Data::Frequencies;

   while (!textStream.atEnd()) {
      // Frequency:
      tokens = textStream.nextLineAsTokens();
      if (tokens.size() < 2 || !tokens[0].contains("Frequency:")) break;

      v1 = 0;  v2 = 0;  v3 = 0;

      if (tokens.size() == 4) {
         w = tokens[3].toDouble(&ok);
         if (!ok) goto error;
         v3 = new Data::VibrationalMode(w);
      }
      if (tokens.size() >= 3) {
         w = tokens[2].toDouble(&ok);
         if (!ok) goto error;
         v2 = new Data::VibrationalMode(w);
      }
      if (tokens.size() >= 2) {
         w = tokens[1].toDouble(&ok);
         if (!ok) goto error;
         v1 = new Data::VibrationalMode(w);
      }

      // Skip Force Cnst and Red. Mass
      // IR Active:
      tokens = textStream.seekAndSplit("IR Active:");
      if (tokens.size() < 3 || !tokens[1].contains("Active:")) goto error;
      if (tokens.size() == 5 && v3) v3->setIrActive(tokens[4].contains("YES"));
      if (tokens.size() >= 4 && v2) v2->setIrActive(tokens[3].contains("YES"));
      if (tokens.size() >= 3 && v1) v1->setIrActive(tokens[2].contains("YES"));

      // IR Intens:
      tokens = textStream.nextLineAsTokens();
      if (tokens.size() < 3 || !tokens[1].contains("Intens:")) goto error;

      if (tokens.size() == 5) {
         w = tokens[4].toDouble(&ok);
         if (!ok) goto error;
         if (v3) v3->setIntensity(w);
      }
      if (tokens.size() >= 4) {
         w = tokens[3].toDouble(&ok);
         if (!ok) goto error;
         if (v2) v2->setIntensity(w);
      }
      if (tokens.size() >= 3) {
         w = tokens[2].toDouble(&ok);
         if (!ok) goto error;
         if (v1) v1->setIntensity(w);
      }

      // Raman Active:
      tokens = textStream.nextLineAsTokens();
      if (tokens.size() < 2 || !tokens[0].contains("Raman")) goto error;
      if (tokens.size() == 5 && v3) v3->setRamanActive(tokens[4].contains("YES"));
      if (tokens.size() >= 4 && v2) v2->setRamanActive(tokens[3].contains("YES"));
      if (tokens.size() >= 3 && v1) v1->setRamanActive(tokens[2].contains("YES"));

      // Raman Intens: (maybe)
      tokens = textStream.nextLineAsTokens();
      if (tokens.size() > 2 && tokens[1].contains("Intens:")) {
         frequencies->haveRaman(true);
         if (tokens.size() == 5) {
            w = tokens[4].toDouble(&ok);
            if (!ok) goto error;
            if (v3) v3->setRamanIntensity(w);
         }
         if (tokens.size() >= 4) {
            w = tokens[3].toDouble(&ok);
            if (!ok) goto error;
            if (v2) v2->setRamanIntensity(w);
         }
         if (tokens.size() >= 3) {
            w = tokens[2].toDouble(&ok);
            if (!ok) goto error;
            if (v1) v1->setRamanIntensity(w);
         }
         // Skip Depolar and X Y Z lines
         textStream.skipLine(2); 
      }

      // Eigenvectors
      unsigned atomCount(0);
      while (!textStream.atEnd()) {
         tokens = textStream.nextLineAsTokens();
         if (tokens.size() < 4 || tokens[0].contains("TransDip")) break;
         ++atomCount;

         if (partialHessianAtomList.isEmpty() ||
             partialHessianAtomList.contains(atomCount)) {
            if (tokens.size() == 10) {
               x = tokens[7].toDouble(&ok);  if (!ok) goto error;
               y = tokens[8].toDouble(&ok);  if (!ok) goto error;
               z = tokens[9].toDouble(&ok);  if (!ok) goto error;
               if (v3) v3->appendDirectionVector(Vec(x,y,z)); 
            }
            if (tokens.size() >= 7) {
               x = tokens[4].toDouble(&ok);  if (!ok) goto error;
               y = tokens[5].toDouble(&ok);  if (!ok) goto error;
               z = tokens[6].toDouble(&ok);  if (!ok) goto error;
               if (v2) v2->appendDirectionVector(Vec(x,y,z)); 
            }
            if (tokens.size() >= 4) {
               x = tokens[1].toDouble(&ok);  if (!ok) goto error;
               y = tokens[2].toDouble(&ok);  if (!ok) goto error;
               z = tokens[3].toDouble(&ok);  if (!ok) goto error;
               if (v1) v1->appendDirectionVector(Vec(x,y,z)); 
            }
         }else {
            if (v1) v1->appendDirectionVector(Vec(0,0,0)); 
            if (v2) v2->appendDirectionVector(Vec(0,0,0)); 
            if (v3) v3->appendDirectionVector(Vec(0,0,0)); 
         }
      }

      // For partial hessian jobs, we may need to top up the eigenvectors
      // with zeros for the frozen atoms.
      while (atomCount < nAtoms) {
         if (v1) v1->appendDirectionVector(Vec(0,0,0)); 
         if (v2) v2->appendDirectionVector(Vec(0,0,0)); 
         if (v3) v3->appendDirectionVector(Vec(0,0,0)); 
         ++atomCount;
      }
      
      if (v1) { frequencies->append(v1);  v1 = 0; }
      if (v2) { frequencies->append(v2);  v2 = 0; }
      if (v3) { frequencies->append(v3);  v3 = 0; }

      textStream.skipLine(2);
   }

   line = textStream.seek("Zero point vibrational energy:");
   tokens = TextStream::tokenize(line);
   if (tokens.size() == 6) zpve = tokens[4].toDouble(); 

   line = textStream.seek("Total Enthalpy:");
   tokens = TextStream::tokenize(line);
   if (tokens.size() == 4) enthalpy = tokens[2].toDouble(); 

   line = textStream.seek("Total Entropy:");
   tokens = TextStream::tokenize(line);
   if (tokens.size() == 4) entropy = tokens[2].toDouble(); 

   frequencies->setThermochemicalData(zpve, entropy, enthalpy);
   m_dataBank.append(frequencies);
   return;

   error:
     QString msg("Problem parsing vibrational frequencies, line ");
     m_errors.append(msg += QString::number(textStream.lineNumber()));
qDebug() << "ERROR: " << msg;
     if (v1) delete v1;
     if (v2) delete v2;
     if (v3) delete v3;
     delete frequencies;
}


void QChemOutput::readPartialHessian(TextStream& textStream, Data::Geometry& geometry, 
   QList<unsigned>& partialHessianAtomList)
{
   textStream.seek("Hessian Limited to Following Atoms"); 
   textStream.skipLine();  // I     At.No.     X           Y           Z

   QStringList tokens(textStream.nextLineAsTokens());

   partialHessianAtomList.clear();
   int  atomIndex(0);
   bool ok(true);

   while (tokens.size() >= 5) {
      atomIndex = tokens[0].toUInt(&ok);
      if (ok) partialHessianAtomList.append(atomIndex);
      tokens = textStream.nextLineAsTokens();
   }

   qDebug() << "Partial Hessian atom list" << partialHessianAtomList;
   textStream.seek("Hessian of the SCF Energy"); 

   unsigned nAtoms(partialHessianAtomList.size());
   Matrix hessian({3*nAtoms, 3*nAtoms});

   if (readHessian(textStream, hessian) ) {
      Data::Hessian& h(geometry.getProperty<Data::Hessian>());
      h.setPartialData(geometry.nAtoms(), partialHessianAtomList, hessian);
   }
}


void QChemOutput::readHessian(TextStream& textStream, Data::Geometry& geometry)
{
   unsigned nAtoms(geometry.nAtoms());
   Matrix hessian({3*nAtoms, 3*nAtoms});

   if (readHessian(textStream, hessian) ) {
      Data::Hessian& h(geometry.getProperty<Data::Hessian>());
      h.setData(hessian);
   }
}


bool QChemOutput::readHessian(TextStream& textStream, Matrix& hessian)
{
   unsigned dim(hessian.shape()[0]);  // 3*nAtoms
   QStringList tokens;
   QList<double> values;

   unsigned firstCol(0);
   unsigned lastCol(0);
   unsigned nCol(0);

   while (firstCol < dim) {
       // header line
       tokens  = textStream.nextLineAsTokens();
       nCol    = tokens.size();
       lastCol = firstCol + tokens.size();

       for (unsigned row = 0; row < dim; ++row) {
           values = textStream.nextLineAsDoubles();
           if ((unsigned)values.size() != lastCol-firstCol+1) {  // +1 for the row index
              QString msg("Problem parsing hessian, line number ");
              m_errors.append(msg + QString::number(textStream.lineNumber()));
              return false;
           }
           values.removeFirst();
           for (unsigned col = firstCol; col < lastCol; ++col) {
               hessian(row, col) = values.takeFirst();
           }
       }
       firstCol += nCol;
   }

   return true;
}


void QChemOutput::readDipoleMoment(TextStream& textStream, Data::Geometry& geometry)
{
   QStringList tokens;
   tokens = textStream.nextLineAsTokens();
   if (tokens.size() != 6) goto error;

   bool ok;
   double x, y, z;

   x = tokens[1].toDouble(&ok);  if (!ok) goto error;
   y = tokens[3].toDouble(&ok);  if (!ok) goto error;
   z = tokens[5].toDouble(&ok);  if (!ok) goto error;

   geometry.getProperty<Data::DipoleMoment>().setValue(x,y,z);
   return;

   error:
      QString msg("Problem parsing dipole moment, line number ");
      m_errors.append(msg + QString::number(textStream.lineNumber()));
}


void QChemOutput::readNmrReference(TextStream& textStream, Data::Nmr& nmr)
{
   qDebug() << "Reading NMR Reference";

   int n;
   QString atom;
   double shift(0.0), offset(0.0);
   bool done(false), ok(true);
   QStringList tokens;

   Data::NmrReference ref;

   QString method;

   while (!textStream.atEnd() && !done && ok) {
      tokens = textStream.nextLineAsTokens();
      n = tokens.size();

      if (n >= 3) {
         if (tokens[0] == "Reference") {
            ref.setSystem(tokens[2]);
         }

      }else if (n >= 2) {
         if (tokens[0] == "Atom:") {
            atom = tokens[1];
         }else if (tokens[0] == "Method:") {
            method = tokens[1];
         }else if (tokens[0] == "Basis:") {
            method += "/" + tokens[1];
            ref.setMethod(method);
         }else if (tokens[0] == "Shift:") {
            shift = tokens[1].toDouble(&ok);
         }else if (tokens[0] == "Offset:") {
            offset = tokens[1].toDouble(&ok);
            ref.addElement(atom, shift, offset);
         }
      
      } else if (n > 0 && tokens[0].contains("-------")) {
         done = true;
      }
   }

   if (ok) {
      nmr.setReference(ref);
   }else {
      m_errors.append("Problem parsing NMR reference ");
   }
}


void QChemOutput::readNmrShifts(TextStream& textStream, Data::Geometry& geometry, 
   Data::Nmr& nmr)
{
   qDebug() << "Reading NMR Shifts";
   QStringList tokens;

   QList<double> shieldings;
   QList<double> shifts;
   QStringList   atomicSymbols;

   int n;
   bool done(false), allOk(true), ok;
   bool haveShifts(false);

   while (!textStream.atEnd() && !done && allOk) {
      tokens = textStream.nextLineAsTokens();
      n = tokens.size();

      if (n == 6) {
         haveShifts = true;
         shifts.append(tokens[5].toDouble(&ok)); 
         allOk = allOk && ok;
      }else if (n == 5) {
         shifts.append(0.0);
      }

      if (n >= 5) {
         shieldings.append(tokens[3].toDouble(&ok)); 
         allOk = allOk && ok;
         atomicSymbols.append(tokens[1]);
      }else {
         done = true;
      }
   }

   if (!allOk) {
      QString msg("Problem parsing NMR shifts, line number ");
      m_errors.append(msg + QString::number(textStream.lineNumber()));
      return;
   }

   if (!geometry.sameAtoms(atomicSymbols)) {
      QString msg("Atom list mismatch around line number: ");
      m_errors.append(msg + QString::number(textStream.lineNumber()));
      return;
   }

   qDebug() << "Setting Shieldings" << shieldings;
   allOk = geometry.setAtomicProperty<Data::NmrShielding>(shieldings);

   if (allOk) { 
      nmr.setAtomLabels(atomicSymbols);
      nmr.setShieldings(shieldings);
   }else {
      m_errors.append("Failed to read NMR shieldings");
   }

   if (haveShifts) {
      nmr.setShifts(shifts);
      qDebug() << "Setting chemical shifts" << shifts;
      allOk = geometry.setAtomicProperty<Data::NmrShift>(shifts);
      if (!allOk) m_errors.append("Failed to read NMR shifts");
   }
}


void QChemOutput::readNmrCouplings(TextStream& textStream, Data::Geometry& geometry, 
   Data::Nmr& nmr)
{
   qDebug() << "Reading NMR coupling constants";

   QStringList tokens;

   bool done(false), allOk(true);
   unsigned nAtoms(geometry.nAtoms());

   Matrix* couplings = new Matrix({nAtoms, nAtoms});
   for (unsigned i = 0; i < nAtoms; ++i) {
       for (unsigned j = 0; j < nAtoms; ++j) {
           (*couplings)(i,j) = 0.0;
       }
   }

   QRegularExpression rx("#(\\d+)");
   QRegularExpressionMatch match;

   while (!textStream.atEnd() && !done && allOk) {
      tokens = textStream.nextNonEmptyLineAsTokens();

      if (tokens.first() == "Atoms" && tokens.size() > 6) {

         int atom1(0), atom2(0);
         match = rx.match(tokens[2]);
         if (allOk && match.hasMatch()) {
             atom1 = match.capturedTexts().at(1).toInt(&allOk);
         }
         match = rx.match(tokens[5]);
         if (allOk && match.hasMatch()) {
            atom2 = match.capturedTexts().at(1).toInt(&allOk);
         }

         if (atom1 > 0 && atom2 > 0 && allOk) {
            textStream.seek("Total Spin-Spin Coupling Tensor");
            textStream.skipLine(4);
    
            tokens = textStream.nextLineAsTokens();
            if (tokens.size() > 2) {
               (*couplings)(atom1-1, atom2-1) = tokens[1].toDouble(&allOk);
               (*couplings)(atom2-1, atom1-1) = (*couplings)(atom1-1, atom2-1);
            }

         }else {
            allOk = false;
            break;
         }
  
         
      }else if (tokens.first() == "MO-PROP") {
         done = true;
      }
   }

   if (allOk) { 
      nmr.setCouplings(*couplings);
      // This is a bit of a hack.  The couplings calculation is done seperately
      // and so the shifts/shieldings are possibly not available.
      geometry.setAtomicProperty<Data::NmrShift>(nmr.shifts());
      geometry.setAtomicProperty<Data::NmrShielding>(nmr.shieldings());
   }else {
      m_errors.append("Failed to read NMR ISS couplings");
   }

   delete couplings;
}


void QChemOutput::readNBO(TextStream& textStream, Data::Geometry& geometry, 
   Data::Type::ID type)
{
   QStringList tokens;

   QList<double> charges;
   QList<double> spins;
   QStringList atomicSymbols;

   int n;
   bool done(false), allOk(true), ok;

   while (!textStream.atEnd() && !done && allOk) {
      tokens = textStream.nextLineAsTokens();
      n = tokens.size();

      if (n >=3) {
         charges.append(tokens[2].toDouble(&ok)); 
         allOk = allOk && ok;
         atomicSymbols.append(tokens[0]);
      }else {
         done = true;
      }
   }

   if (!allOk) {
      QString msg("Problem parsing charges, line number: ");
      m_errors.append(msg + QString::number(textStream.lineNumber()));
      return;
   }

   if (!geometry.sameAtoms(atomicSymbols)) {
      QString msg("Atom list mismatch around line number: ");
      m_errors.append(msg + QString::number(textStream.lineNumber()));
      return;
   }

   allOk = geometry.setAtomicProperty<Data::NaturalCharge>(charges);

   if (allOk) {
      double q(0.0);
      for (int i = 0; i < charges.size(); ++i) q += charges[i];
      geometry.setCharge(Math::round(q));
   }else {
      m_errors.append("Problem setting atomic charges");
   }
}


void QChemOutput::readCharges(TextStream& textStream, Data::Geometry& geometry, 
   Data::Type::ID type)
{
   //qDebug() << "Reading charge group" << Data::Type::toString(type);
   QStringList tokens;

   QList<double> charges;
   QList<double> spins;
   QStringList atomicSymbols;

   int n;
   bool done(false), allOk(true), ok;

   while (!textStream.atEnd() && !done && allOk) {
      tokens = textStream.nextLineAsTokens();
      n = tokens.size();

      if (n == 4) {
         spins.append(tokens[3].toDouble(&ok)); 
         allOk = allOk && ok;
      }

      if (n >=3) {
         charges.append(tokens[2].toDouble(&ok)); 
         allOk = allOk && ok;
         atomicSymbols.append(tokens[1]);
      }else {
         done = true;
      }
   }

   if (!allOk) {
      QString msg("Problem parsing charges, line number: ");
      m_errors.append(msg + QString::number(textStream.lineNumber()));
      return;
   }

   if (!geometry.sameAtoms(atomicSymbols)) {
      QString msg("Atom list mismatch around line number: ");
      m_errors.append(msg + QString::number(textStream.lineNumber()));
      return;
   }

   if (type == Data::Type::MullikenCharge) {
      allOk = geometry.setAtomicProperty<Data::MullikenCharge>(charges);
      if (allOk && !spins.isEmpty()) {
         allOk = allOk && geometry.setAtomicProperty<Data::SpinDensity>(spins);
      }
   }else if (type == Data::Type::MultipoleDerivedCharge) {
      allOk = geometry.setAtomicProperty<Data::MultipoleDerivedCharge>(charges);
   }else if (type == Data::Type::ChelpgCharge) {
      allOk = geometry.setAtomicProperty<Data::ChelpgCharge>(charges);
   }else if (type == Data::Type::HirshfeldCharge) {
      allOk = geometry.setAtomicProperty<Data::HirshfeldCharge>(charges);
   }else if (type == Data::Type::LowdinCharge) {
      allOk = geometry.setAtomicProperty<Data::LowdinCharge>(charges);
   }else {
      m_errors.append("Unknown charge type");
   }

   if (allOk) {
      double q(0.0);
      for (int i = 0; i < charges.size(); ++i) q += charges[i];
      geometry.setCharge(Math::round(q));
   }else {
      m_errors.append("Problem setting atomic charges");
   }
}


Data::Geometry* QChemOutput::readStandardCoordinates(TextStream& textStream)
{  
   CartesianCoordinates parser;
   Data::Geometry* geometry(parser.parse(textStream));
   if (geometry) {
      QString error(parser.error());
      if (!error.isEmpty()) {
         m_errors.append(error);
         delete geometry;
         geometry = 0;
      }
   }else {
      m_errors.append("No coordinates found");
   }

   return geometry;
} 

} } // end namespace IQmol::Parser
